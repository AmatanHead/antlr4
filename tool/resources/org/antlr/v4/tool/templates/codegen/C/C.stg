/*
 * [The "BSD license"]
 *  Copyright (c) 2019, Vladimir Goncharov
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *  3. The name of the author may not be used to endorse or promote products
 *     derived from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 *  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 *  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

cppTypeInitMap ::= [
    "int": "0",
    "long": "0",
    "float": "0.0f",
    "double": "0.0",
    "bool": "false",
    "short": "0",
    "char": "0",
    default: "NULL"
]

codeFileExtension() ::= ".c"
headerFileExtension() ::= ".h"


fileHeader(grammarFileName, ANTLRVersion, header) ::= "(void)0;"
LexerFileHeader(file, lexer, namedActions) ::= "(void)0;"
LexerFile(file, lexer, namedActions) ::= "(void)0;"
ParserFileHeader(file, parser, namedActions, contextSuperClass) ::= "(void)0;"
ParserFile(file, parser, namedActions, contextSuperClass) ::= "(void)0;"
BaseListenerFileHeader(file, header, namedActions) ::= "(void)0;"
BaseListenerFile(file, header, namedActions) ::= "(void)0;"
ListenerFileHeader(file, header, namedActions) ::= "(void)0;"
ListenerFile(file, header, namedActions) ::= "(void)0;"
BaseVisitorFileHeader(file, header, namedActions) ::= "(void)0;"
BaseVisitorFile(file, header, namedActions) ::= "(void)0;"
VisitorFileHeader(file, header, namedActions) ::= "(void)0;"
VisitorFile(file, header, namedActions) ::= "(void)0;"


LexerHeader(lexer, atn, actionFuncs, sempredFuncs, superClass = {}) ::= "(void)0;"
Lexer(lexer, atn, actionFuncs, sempredFuncs, superClass = {}) ::= "(void)0;"
RuleActionFunctionHeader(r, actions) ::= "(void)0;"
RuleActionFunction(r, actions) ::= "(void)0;"
RuleSempredFunctionHeader(r, actions) ::= "(void)0;"
RuleSempredFunction(r, actions) ::= "(void)0;"
ParserHeader(parser, funcs, atn, sempredFuncs, superClass = {}) ::= "(void)0;"
Parser(parser, funcs, atn, sempredFuncs, superClass = {}) ::= "(void)0;"
SerializedATNHeader(model) ::= "(void)0;"
SerializedATN(model) ::= "(void)0;"
RuleFunctionHeader(currentRule, args, code, locals, ruleCtx, altLabelCtxs, namedActions, finallyAction, postamble, exceptions) ::= "(void)0;"
RuleFunction(currentRule, args, code, locals, ruleCtx, altLabelCtxs, namedActions, finallyAction, postamble, exceptions) ::= "(void)0;"
LeftRecursiveRuleFunctionHeader(currentRule, args, code, locals, ruleCtx, altLabelCtxs, namedActions, finallyAction, postamble) ::= "(void)0;"
LeftRecursiveRuleFunction(currentRule, args, code, locals, ruleCtx, altLabelCtxs, namedActions, finallyAction, postamble) ::= "(void)0;"
StructDeclHeader(struct, ctorAttrs, attrs, getters, dispatchMethods, interfaces, extensionMembers) ::= "(void)0;"
StructDecl(struct, ctorAttrs, attrs, getters, dispatchMethods, interfaces, extensionMembers) ::= "(void)0;"
AltLabelStructDeclHeader(struct, attrs, getters, dispatchMethods) ::= "(void)0;"
AltLabelStructDecl(struct, attrs, getters, dispatchMethods) ::= "(void)0;"
CodeBlockForOuterMostAltHeader(currentOuterMostAltCodeBlock, locals, preamble, ops) ::= "(void)0;"
CodeBlockForOuterMostAlt(currentOuterMostAltCodeBlock, locals, preamble, ops) ::= "(void)0;"
CodeBlockForAltHeader(currentAltCodeBlock, locals, preamble, ops) ::= "(void)0;"
CodeBlockForAlt(currentAltCodeBlock, locals, preamble, ops) ::= "(void)0;"
LL1AltBlockHeader(choice, preamble, alts, error) ::= "(void)0;"
LL1AltBlock(choice, preamble, alts, error) ::= "(void)0;"
LL1OptionalBlockHeader(choice, alts, error) ::= "(void)0;"
LL1OptionalBlock(choice, alts, error) ::= "(void)0;"
LL1OptionalBlockSingleAltHeader(choice, expr, alts, preamble, error, followExpr) ::= "(void)0;"
LL1OptionalBlockSingleAlt(choice, expr, alts, preamble, error, followExpr) ::= "(void)0;"
LL1StarBlockSingleAltHeader(choice, loopExpr, alts, preamble, iteration) ::= "(void)0;"
LL1StarBlockSingleAlt(choice, loopExpr, alts, preamble, iteration) ::= "(void)0;"
LL1PlusBlockSingleAltHeader(choice, loopExpr, alts, preamble, iteration) ::= "(void)0;"
LL1PlusBlockSingleAlt(choice, loopExpr, alts, preamble, iteration) ::= "(void)0;"
AltBlockHeader(choice, preamble, alts, error) ::= "(void)0;"
AltBlock(choice, preamble, alts, error) ::= "(void)0;"
OptionalBlockHeader(choice, alts, error) ::= "(void)0;"
OptionalBlock(choice, alts, error) ::= "(void)0;"
StarBlockHeader(choice, alts, sync, iteration) ::= "(void)0;"
StarBlock(choice, alts, sync, iteration) ::= "(void)0;"
PlusBlockHeader(choice, alts, error) ::= "(void)0;"
PlusBlock(choice, alts, error) ::= "(void)0;"
Sync(s) ::= "(void)0;"
ThrowNoViableAltHeader(t) ::= "(void)0;"
ThrowNoViableAlt(t) ::= "(void)0;"
TestSetInlineHeader(s) ::= "(void)0;"
TestSetInline(s) ::= "(void)0;"
testShiftInRange(shiftAmount) ::= "(void)0;"
bitsetBitfieldComparison(s, bits) ::= "(void)0;"
isZero ::= "(void)0;"
offsetShift(shiftAmount, offset, prefix = false) ::= "(void)0;"
bitsetInlineComparison(s, bits) ::= "(void)0;"
cases(ttypes) ::= "(void)0;"
InvokeRuleHeader(r, argExprsChunks) ::= "(void)0;"
InvokeRule(r, argExprsChunks) ::= "(void)0;"
MatchTokenHeader(m) ::= "(void)0;"
MatchToken(m) ::= "(void)0;"
MatchSetHeader(m, expr, capture) ::= "(void)0;"
MatchSet(m, expr, capture) ::= "(void)0;"
MatchNotSetHeader(m, expr, capture) ::= "(void)0;"
MatchNotSet(m, expr, capture) ::= "(void)0;"
CommonSetStuff(m, expr, capture, invert) ::= "(void)0;"
WildcardHeader(w) ::= "(void)0;"
Wildcard(w) ::= "(void)0;"
ActionHeader(a, foo, chunks) ::= "(void)0;"
Action(a, foo, chunks) ::= "(void)0;"
ArgAction(a, chunks) ::= "(void)0;"
SemPredHeader(p, chunks, failChunks) ::= "(void)0;"
SemPred(p, chunks, failChunks) ::= "(void)0;"
ExceptionClauseHeader(e, catchArg, catchAction) ::= "(void)0;"
ExceptionClause(e, catchArg, catchAction) ::= "(void)0;"
LexerSkipCommand() ::= "(void)0;"
LexerMoreCommand() ::= "(void)0;"
LexerPopModeCommand() ::= "(void)0;"
LexerTypeCommand(arg, grammar) ::= "(void)0;"
LexerChannelCommand(arg, grammar) ::= "(void)0;"
LexerModeCommand(arg, grammar) ::= "(void)0;"
LexerPushModeCommand(arg, grammar) ::= "(void)0;"
ActionTextHeader(t) ::= "(void)0;"
ActionText(t) ::= "(void)0;"
ActionTemplateHeader(t) ::= "(void)0;"
ActionTemplate(t) ::= "(void)0;"
ArgRefHeader(t) ::= "(void)0;"
ArgRef(a) ::= "(void)0;"
LocalRefHeader(t) ::= "(void)0;"
LocalRef(a) ::= "(void)0;"
RetValueRefHeader(t) ::= "(void)0;"
RetValueRef(a) ::= "(void)0;"
QRetValueRefHeader(t) ::= "(void)0;"
QRetValueRef(a) ::= "(void)0;"
TokenRefHeader(t) ::= "(void)0;"
TokenRef(t) ::= "(void)0;"
LabelRefHeader(t) ::= "(void)0;"
LabelRef(t) ::= "(void)0;"
ListLabelRefHeader(t) ::= "(void)0;"
ListLabelRef(t) ::= "(void)0;"
SetAttrHeader(t) ::= "(void)0;"
SetAttr(s,rhsChunks) ::= "(void)0;"
InputSymbolType() ::= "(void)0;"
TokenPropertyRef_textHeader(t) ::= "(void)0;"
TokenPropertyRef_text(t) ::= "(void)0;"
TokenPropertyRef_typeHeader(t) ::= "(void)0;"
TokenPropertyRef_type(t) ::= "(void)0;"
TokenPropertyRef_lineHeader(t) ::= "(void)0;"
TokenPropertyRef_line(t) ::= "(void)0;"
TokenPropertyRef_posHeader(t) ::= "(void)0;"
TokenPropertyRef_pos(t) ::= "(void)0;"
TokenPropertyRef_channelHeader(t) ::= "(void)0;"
TokenPropertyRef_channel(t) ::= "(void)0;"
TokenPropertyRef_indexHeader(t) ::= "(void)0;"
TokenPropertyRef_index(t) ::= "(void)0;"
TokenPropertyRef_intHeader(t) ::= "(void)0;"
TokenPropertyRef_int(t) ::= "(void)0;"
RulePropertyRef_startHeader(r) ::= "(void)0;"
RulePropertyRef_start(r) ::= "(void)0;"
RulePropertyRef_stopHeader(r) ::= "(void)0;"
RulePropertyRef_stop(r) ::= "(void)0;"
RulePropertyRef_textHeader(r) ::= "(void)0;"
RulePropertyRef_text(r) ::= "(void)0;"
RulePropertyRef_ctxHeader(r) ::= "(void)0;"
RulePropertyRef_ctx(r) ::= "(void)0;"
ThisRulePropertyRef_start(r) ::= "(void)0;"
ThisRulePropertyRef_stop(r) ::= "(void)0;"
ThisRulePropertyRef_textHeader(r) ::= "(void)0;"
ThisRulePropertyRef_text(r) ::= "(void)0;"
ThisRulePropertyRef_ctxHeader(r) ::= "(void)0;"
ThisRulePropertyRef_ctx(r) ::= "(void)0;"
ThisRulePropertyRef_parserHeader(r) ::= "(void)0;"
ThisRulePropertyRef_parser(r) ::= "(void)0;"
NonLocalAttrRef(s) ::= "(void)0;"
SetNonLocalAttr(s, rhsChunks) ::= "(void)0;"
AddToLabelListHeader(a) ::= "(void)0;"
AddToLabelList(a) ::= "(void)0;"
TokenLabelType() ::= "(void)0;"
TokenDeclHeader(t) ::= "(void)0;"
TokenDecl(t) ::= "(void)0;"
TokenTypeDeclHeader(t) ::= "(void)0;"
TokenTypeDecl(t) ::= "(void)0;"
TokenListDeclHeader(t) ::= "(void)0;"
TokenListDecl(t) ::= "(void)0;"
RuleContextDeclHeader(r) ::= "(void)0;"
RuleContextDecl(r) ::= "(void)0;"
RuleContextListDeclHeader(rdecl) ::= "(void)0;"
RuleContextListDecl(rdecl) ::= "(void)0;"
ContextTokenGetterDeclHeader(t) ::= "(void)0;"
ContextTokenGetterDecl(t) ::= "(void)0;"
ContextTokenListGetterDeclHeader(t) ::= "(void)0;"
ContextTokenListGetterDecl(t) ::= "(void)0;"
ContextTokenListIndexedGetterDeclHeader(t) ::= "(void)0;"
ContextTokenListIndexedGetterDecl(t) ::= "(void)0;"
ContextRuleGetterDeclHeader(r) ::= "(void)0;"
ContextRuleGetterDecl(r) ::= "(void)0;"
ContextRuleListGetterDeclHeader(r) ::= "(void)0;"
ContextRuleListGetterDecl(r) ::= "(void)0;"
ContextRuleListIndexedGetterDeclHeader(r) ::= "(void)0;"
ContextRuleListIndexedGetterDecl(r) ::= "(void)0;"
LexerRuleContext() ::= "(void)0;"
RuleContextNameSuffix() ::= "(void)0;"
ImplicitTokenLabel(tokenName) ::= "(void)0;"
ImplicitRuleLabel(ruleName) ::= "(void)0;"
ImplicitSetLabel(id) ::= "(void)0;"
ListLabelName(label) ::= "(void)0;"
CaptureNextToken(d) ::= "(void)0;"
CaptureNextTokenTypeHeader(d) ::= "(void)0;"
CaptureNextTokenType(d) ::= "(void)0;"
ListenerDispatchMethodHeader(method) ::= "(void)0;"
ListenerDispatchMethod(method) ::= "(void)0;"
VisitorDispatchMethodHeader(method) ::= "(void)0;"
VisitorDispatchMethod(method) ::= "(void)0;"
AttributeDeclHeader(d) ::= "(void)0;"
AttributeDecl(d) ::= "(void)0;"
labelref(x) ::= "(void)0;"
ctx(actionChunk) ::= "(void)0;"
recRuleAltPredicate(ruleName,opPrec) ::= "(void)0;"
recRuleSetReturnAction(src,name) ::= "(void)0;"
recRuleSetStopToken() ::= "(void)0;"
recRuleAltStartAction(ruleName, ctxName, label) ::= "(void)0;"
recRuleLabeledAltStartAction(ruleName, currentAltLabel, label, isListLabel) ::= "(void)0;"
recRuleReplaceContext(ctxName) ::= "(void)0;"
recRuleSetPrevCtx() ::= "(void)0;"
initValue(typeName) ::= "(void)0;"
